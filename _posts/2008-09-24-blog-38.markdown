---
layout: post
title: Linux内核源代码情景分析读书笔记(5)－关于fork/clone/vfork
date: 2008-09-24 14:09
comments: true
author: Peter.Y
categories: linux
---

* content
{:toc}



　　（最近又回到Linux内核的怀抱中了。继续呵。）

　　首先说明Linux下的进程与线程比较相近。这么说的一个原因是它们都采用相同的数据结构来表示，即`task_struct`。区别在于一个有独立的用户空间，一个是共享的用户空间（如果完全没有用户空间则是内核线程，不需要）。

　　Linux的用户进程不能直接被创建出来，因为不存在这样的API。它只能从某个进程中复制出来，再通过EXEC这样的API来切换到实际想要运行的程序文件。

　　复制的API包括三种：fork、clone、vfork。

　　这三个API的内部实际都是调用一个内核内部函数`do_fork`，只是填写的参数不同而已。

　　vfork，其实就是fork的部分过程，用以简化并提高效率。而fork与clone是有区别的。fork是进程资源的完全复制，包括进程的PCB、进程的系统堆栈、进程的用户空间、进程打开的设备等。而在clone中其实只有前两项是被复制了的，后两项都与父进程共享。

　　在四项资源的复制中，用户空间是相对庞大的，如果完全复制则效率会很低。在Linux中采用的是"写时复制"技术，也就是说，fork执行时并不真正复制用户空间的所有页面，而只是复制页面表。这样，无论父进程还是子进程，当发生用户空间的写操作时，都会引发"写复制"操作，从而另行分配一块可用的用户空间，使其完全独立。这是一种提高效率的非常有效的方法。

　　而对于clone来说，它们连这些页面表都是与父进程共享，故而是真正意义上的共享，因此对共享数据的保护必须由上层应用来保证。

